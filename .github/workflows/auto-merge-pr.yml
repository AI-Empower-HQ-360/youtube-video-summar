name: Auto Merge PR

on:
  pull_request:
    types: [opened, synchronize, reopened]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI", "Backend CI", "E2E Tests"]
    types: [completed]

permissions:
  pull-requests: write
  contents: write
  checks: read

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    steps:
      - name: Check PR status and merge
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const prNumber = context.payload.pull_request?.number || 
                           context.payload.workflow_run?.pull_requests[0]?.number;
            
            if (!prNumber) {
              console.log('No PR number found');
              return;
            }
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Check if PR has auto-merge label or is from bot
            const hasAutoMergeLabel = pr.labels.some(label => 
              label.name === 'auto-merge' || label.name === 'dependencies'
            );
            
            const isBot = pr.user.login.includes('bot') || pr.user.login.includes('dependabot');
            
            if (!hasAutoMergeLabel && !isBot) {
              console.log('PR does not have auto-merge label and is not from bot');
              return;
            }
            
            // Get all checks
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            
            // Check if all checks passed
            const allChecksPassed = checks.check_runs.every(check => 
              check.status === 'completed' && check.conclusion === 'success'
            );
            
            if (!allChecksPassed) {
              console.log('Not all checks passed yet');
              return;
            }
            
            // Check PR reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const hasApproval = reviews.some(review => review.state === 'APPROVED');
            const hasChangesRequested = reviews.some(review => review.state === 'CHANGES_REQUESTED');
            
            // For bots, skip review requirement
            if (!isBot && !hasApproval) {
              console.log('PR needs approval');
              return;
            }
            
            if (hasChangesRequested) {
              console.log('PR has changes requested');
              return;
            }
            
            // Merge PR
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: pr.title,
                commit_message: `${pr.body || ''}\n\nAuto-merged by GitHub Actions`
              });
              
              console.log(`Successfully merged PR #${prNumber}`);
              
              // Delete branch after merge
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${pr.head.ref}`
                });
                console.log(`Deleted branch ${pr.head.ref}`);
              } catch (error) {
                console.log('Could not delete branch:', error.message);
              }
            } catch (error) {
              console.log('Failed to merge:', error.message);
            }
